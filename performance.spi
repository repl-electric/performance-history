load_support('piezoelectric_resonator'); use_bpm 127; alive perc: 1, pitch: 0, kick: 1

#init
#create_sea
#create_sea -1
#cam :top
#stop
#error target: :circle, radius: 25, speed: 80
#world time: 2
#stop

#stop
#error radius: 10, target: :circle
##attune
#vol 0
#eject_cpu_core
#unity "/attune/noise", 500
#world time: 1
#unity "/ejectcpu",1


#attune

#eject_cpu_core
#unity "/ejectcpu",1
#unity "/attune",
#stop

#attune
#vol 0
#stop
#cam :top
#world time: 0.2
#eject_cpu_core


#eject_cpu_core

#attune

#vol 1


#attune
#unity "/attune/noise",1.5

#error target: :circle, radius: 30, speed: 100
#eject_cpu_core
#unity "/attune/noise",100
#stop

#eject_cpu_core
#rocks throttle: 0
#rocksinit
#attune
#attune
#vol 0
#overclock_cc motion: 0.39
#e#ject_cpu_core
#world time: 1
#stop
#unity "/fadeout",1


#unity "/attune/noise",1.0
#eject
#vol 0


live_loop :Attune, sync: :unsyncable do; tick
  silence?
  zero_delay [2,5,6].shuffle
  #  overclock :e4,5, sus: 2 if spread(1,4).look
  #operator :e4,105, sus: 3
  overclock :f4, sus: 3 if spread(1,1).look
  overclock_cc oct: (cycle 0 -12 0 19 0 12).look

  with_bpm @bpm=(127*4) do
    #tick_reset_all
    flop_cc motion: (flow 0.4 0.57 32).look
    flip_cc motion: 0.6
    flip :e4,127, sus: (cycle 0.25 0.5 1).look
    fn = (ring
      (method :flip),(method :flip),(method :flip),
      (method :flop),(method :flop),(method :flop) ).look
    flop(:g4,127, sus: (cycle 0.125 0.5 1).rot(look%6).look)

    sleep 1/4.0
    sleep 1/4.0
    sleep 1/4.0
    sleep 1/4.0
#    overclock (cycle :g3  :A3  :G3).look,10,sus: 1.0/12.0 if spread(7,11).look
#    alu (cycle :G3).look if spread(1,4).look

    sleep 1/4.0
    sleep 1/4.0
    sleep 1/4.0
    sleep 1/4.0

    flop :c4,127, sus: 1/2.0

    sleep 1/2.0
    sleep 1/2.0
    sleep 1/2.0
    flop :e4,127, sus: 1/2.0
    sleep 1/2.0
  end
end

live_loop :ClockCycle, sync: :unsyncable do; tick
  #sync :MachineInstructions
  perc=(cycle 0 0 1 1  1 1 0 1  1 0 0 0  0 0 0 0)
  with_bpm 127*(cycle 1).look do
    #perc_machine perc.to_a
    #sleep 1.0/2.0
    with_swing((flow 0.0 1/4.0 16*4).look){
      puts (flow 0.0 1/4.0 16*4).look if spread(4,8).look
      glitch (cycle :cs3 :cs3 :cs3).look, 120 if spread(4,8).look
      glitch_cc corode: rand*2
    }
    sleep 1.0/4.0
  end
end

live_loop :MachineInstructions, sync: :unsyncable do; tick
  with_bpm 127*1 do
    score = (cycle
#      [[:a3] 8]

#      [[:fs3] 8]

      [[:A3 :C5 :E4] 8]
      [[:F4 :A6 :C5] 8]
      [[:C3 :E5 :G4] 4]

      [Zz 4]
      # [[:A3 :C5 :E4] 8]
      # [[:F4 :A6 :C5] 8]
      # [[:D3 :F5 :A4] 4]
      # [Zz 4]


      # [[:A3 :C5 :E4] 8]
      # [[:E4 :G5 :B3] 8]
      # [[:F4 :A6 :C5 :E5] 8]
      # [[:C3 :E5 :G4] 8]
      # [Zz 8]

      # [[:A3 :C5 :E4] 8]
      # [[:F4 :A6 :C5] 8]
      # [[:C3 :E5 :G4] 4]
      # [Zz 4]
      # [[:A3 :C5 :E4] 4]
      # [[:A3 :C5 :E4] 4]
      # [[:E4 :G5 :B3] 4]
      # [[:E4 :G5 :B3] 4]
      # [[:G4 :B6 :D5 :F4] 8]
      # [[:C4 :E5 :G4] 8]
      # [Zz 8]

      )
    chd = score.look[0]
    sleeps = score.look[-1]
    resonate chd[0]+12,1, sus: sleeps, pads: [0,1,2], sat: 0, drive: 0
    #control_unit root(chd)+12, 10,sus: sleeps, drive: 0.0, sat: 0.0

    if chd[0]  == :F4
      at{
        with_swing 0.125 {
        4.times{
            #   operator :Ab4,95, sus: 1/2.0
#            resonate :Ab5,120, sus: 4.0, pads: [1] #Gs4
            sleep 1/2.0
          }
        }
        operator :Ab4,90, sus: 4
        }
      #resonate :Ab5,127, sus: 1.0, pads: [2]
    elsif chd[0] == :C3
      at{
        sleep sleeps/3.0
 #       resonate :F5, 100, sus: sleeps/2.0, pads: [2]
        }
      operator :e4, 98, sus: 12
    end

    #control_unit root(chd), 1,sus: sleeps, drive: 0.0, sat: 0.0

    sleep sleeps/2.0
    operator chd[-1]+[9,7].choose,95, sus: 8
    with_swing((flow 0.0 sleeps/4.0 64).look){
      operator chd[-1]+12+[9,7].choose,91, sus: 8
    }

    sleep sleeps/2.0
  end
end

live_loop(:unsyncable)do;sleep 1.0;end
